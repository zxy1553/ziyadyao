[任务规划完成]
[搜索 AI Wiki]
### 你要的“通用 Debug 方法论”：从**表现**到**定位**、从**改了没生效**到**找到原因**

这套方法论我按你关心的三件事组织：**(1) 调用先后顺序/时序问题**、**(2) 快速理解陌生代码并排查**、**(3) 修改没生效的定位路径**。核心结论是：**不止 Log 和 断点**；更重要的是“怎么组合、怎么收敛范围”。

---

## 1）时序问题：断点 vs 日志，怎么选？

### 结论（非常实用）
- **要看“先后顺序/谁先谁后/是否重入/是否被覆盖”**：优先 **日志**  
  断点会**改变时序**（尤其 Tick、异步、并发、网络、物理子步），很容易把问题“调没了”。
- **要看“当下这个点的变量到底是什么”**：用 **断点**  
  日志只能看到你打印的那点东西，断点能看到全量状态（含调用栈、局部变量、对象成员）。
- **要回答“到底是谁调用了我”**：用 **DumpStack（堆栈）+ 日志**  
  这是快速梳理调用链最省时间的方式之一。

### 你可以用一个“黄金组合”
- **日志**：记录时序（带序号、时间戳、对象ID、线程/世界、关键参数）
- **DumpStack**：仅在关键分支/异常分支触发（避免刷屏）
- **条件断点**：等你通过日志把范围收敛到“某一次调用”后，再精确停下来

---

## 2）最快理解陌生代码：不要从细节读起，从“边界+入口+数据流”读起

你提到“物理初始化牵涉 PhysicsBudget、Avatar 融合”等跨系统逻辑；这种场景读代码最快的方法不是线性读文件，而是：

### Step A：先定“观察点”（Observation Points）
你只有“表现”，就先找**最接近表现**的几个函数点（比如：真正切物理开关/真正写状态的函数）。  
然后问三个问题：
- **写入点**：谁在这里写状态？（Enable/Disable、Init、Reset）
- **覆盖点**：是否后面又被别的系统改回去了？
- **条件点**：哪些条件会跳过/延迟/异步执行？

> 实操上：在“写入点”和“覆盖点”打日志，通常一轮就能看出“谁最后说了算”。

### Step B：用“调用方枚举”替代“通读”
对关键函数做两件事：
- **Find Usages（所有调用点）**
- **每个调用点只看 30 行上下文**：它在什么条件下调用？用的什么参数？什么时候调用？（BeginPlay/Tick/回调/事件）

你会很快得到一个“多入口地图”，而不是陷入某个文件的细节里。

### Step C：按“生命周期/事件源”分类调用链（比按模块分类更快）
把调用分成几类，你就能立刻知道“时序可能哪里乱”：
- **生命周期类**：构造、`BeginPlay`、`OnRegister`、`EndPlay`
- **驱动循环类**：Tick、Timer
- **异步回调类**：网络回包、资源加载完成、Anim/Physics 回调、Delegate
- **状态同步类**：属性系统（Attribute）、GameplayTag、复制（RepNotify）

跨系统时序问题，80% 出在“**两个事件源竞争同一状态**”。

---

## 3）你以为“只有 Log 和断点”？还有这些“更像方法论的工具”

### 3.1 “结构化日志”比“随便 UE_LOG”有效 10 倍
你要解决时序：日志必须可排序、可过滤、可关联。建议统一字段：
- **Seq**：单调递增序号（本对象/全局都行）
- **Time**：`WorldTimeSeconds`（或 `FPlatformTime::Seconds()`）
- **ObjKey**：角色/组件唯一标识（Name + 指针/UID）
- **Phase**：阶段（Init/Apply/Override/Finalize）
- **Reason**：为什么触发（Budget/AvatarMerge/AttrChange/BeginPlay…）

这样你才能“读日志像读时间线”。

并且按你的偏好：日志级别用 **Log/Warning/Error** 即可 [[memory:0i6x0snf]]。

### 3.2 采样点（Trace）/性能时序工具（如果项目允许）
如果你在 UE 环境里，**Unreal Insights**（或 Trace）对“谁先谁后”非常强：它不打断时序，且能看跨线程。  
（这不是让你做性能优化，而是把它当“时序显微镜”。）

### 3.3 断点也有“正确打开方式”：条件断点 + 日志断点
- **条件断点**：只在某个角色、某个次数、某个参数组合停下
- **日志断点**（IDE 支持的话）：不中断，只打印（相当于“无需改代码的 Log”）
这能避免断点把时序搅乱。

---

## 4）“修改没生效”通用定位路径（非常常见）

把“没生效”拆成四类，你基本不会走弯路：

### 4.1 根本没跑到你改的代码（执行路径错误）
- 现象：日志没出现、断点不停
- 常见原因：
  - 实际走的是另一个分支/平台宏/配置
  - 虚函数没 override 到、绑定没生效、注册顺序不对
  - 蓝图/数据驱动覆盖了 C++ 默认值（看起来“改了代码没用”）

**方法**：在你认为必经路径的第一行加一个“强标识日志”，或用 `ensure` 触发一次性提示。

### 4.2 跑到了，但结果被后续覆盖（最终状态不是你写的）
- 现象：你打印“我设置成 true”，但表现还是 false
- 常见原因：后面某系统（Budget/融合/属性同步/Rep）又写回去了

**方法**：在“写入点”加日志，在“状态读取/最终应用点”也加日志；并对“所有写入点”打一次 DumpStack（只在状态变化时打）。

### 4.3 跑到了，也没被覆盖，但你观察的是另一个对象/另一个世界/另一个线程
- 现象：日志显示对 A 改了，实际表现是 B
- 常见原因：对象重建、Pawn 重生、客户端/服务器不是同一个实例、PIE 多世界

**方法**：日志必须带 `ObjKey`（Name+指针/UID）和世界/NetRole 信息。

### 4.4 编译/热更/加载的不是你这份产物（构建链路问题）
- 现象：你改了代码，怎么都看不到变化
- 常见原因：模块没重新编译、加载了旧 DLL、热重载不可靠、运行的是另一个配置/另一个工程

**方法**：在代码里放一个“版本字符串/编译时间戳”日志（临时），启动就能确认是否加载到新产物。

---

## 5）把方法论落成一个“最短闭环”工作流（建议你以后照这个走）

- **1）先选 1~3 个“写入点/最终应用点”**（离表现最近的点）
- **2）结构化日志记录时序**（对象ID + Seq + Time + Reason）
- **3）只在异常/变化时 DumpStack**（快速获得调用链）
- **4）跑一遍收敛到“哪一次调用导致异常”**
- **5）再用条件断点停在那一次**（看变量、看分支、看覆盖链）

这套流程的关键是：**先用日志把空间/时间范围收敛，再用断点做精确检查**。时序问题基本都能这样快速解。

---

- **总结**
  - **时序/先后顺序**优先用**结构化日志 +（必要时）DumpStack**，断点用于“收敛后的精确检查”。
  - **快速理解陌生代码**：从“写入点/覆盖点/入口事件源”入手，用“调用方枚举+生命周期分类”替代通读。
  - **修改没生效**按四类排：**没跑到** / **被覆盖** / **对象不一致** / **产物没更新**，每类都有对应的最快验证手段。